<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hisen.me",root:"/",scheme:"Mist",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="[1]选择最有效率的表名顺序只在基于规则的优化器中有效,ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引"><meta property="og:type" content="article"><meta property="og:title" content="Oracle SQL语句优化 - 写出高效SQL"><meta property="og:url" content="http://hisen.me/20170120-Oracle-SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96-%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88SQL/index.html"><meta property="og:site_name" content="HiSEN"><meta property="og:description" content="[1]选择最有效率的表名顺序只在基于规则的优化器中有效,ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引"><meta property="og:locale"><meta property="article:published_time" content="2017-01-20T06:35:55.000Z"><meta property="article:modified_time" content="2025-07-19T05:54:03.804Z"><meta property="article:author" content="hisenyuan"><meta property="article:tag" content="sql"><meta property="article:tag" content="oracle"><meta property="article:tag" content="oarcle优化"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://hisen.me/20170120-Oracle-SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96-%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88SQL/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-Hans"}</script><title>Oracle SQL语句优化 - 写出高效SQL | HiSEN</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">HiSEN</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Personal Technology Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-booklist"><a href="/booklist" rel="section"><i class="fa fa-list-ol fa-fw"></i>booklist</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="http://hisen.me/20170120-Oracle-SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96-%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88SQL/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="hisenyuan"><meta itemprop="description" content="Java R & D"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="HiSEN"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Oracle SQL语句优化 - 写出高效SQL</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-01-20 14:35:55" itemprop="dateCreated datePublished" datetime="2017-01-20T14:35:55+08:00">2017-01-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2025-07-19 13:54:03" itemprop="dateModified" datetime="2025-07-19T13:54:03+08:00">2025-07-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1-选择最有效率的表名顺序"><a href="#1-选择最有效率的表名顺序" class="headerlink" title="[1]选择最有效率的表名顺序"></a>[1]选择最有效率的表名顺序</h2><p>只在基于规则的优化器中有效,ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须<strong>选择记录条数最少的表作为基础表</strong>。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.</p><h2 id="2-WHERE子句中的连接顺序"><a href="#2-WHERE子句中的连接顺序" class="headerlink" title="[2]WHERE子句中的连接顺序"></a>[2]WHERE子句中的连接顺序</h2><p><strong>ORACLE采用自下而上(从后往前)的顺序解析WHERE子句</strong>,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些<strong>可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾</strong></p><h2 id="3-SELECT子句中避免使用’-’"><a href="#3-SELECT子句中避免使用’-’" class="headerlink" title="[3]SELECT子句中避免使用’*’"></a>[3]SELECT子句中避免使用’*’</h2><p>ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间.需要什么字段就查询什么字段，永远不要查询出不需要的字段来</p><h2 id="4-减少访问数据库的次数"><a href="#4-减少访问数据库的次数" class="headerlink" title="[4]减少访问数据库的次数"></a>[4]减少访问数据库的次数</h2><p>ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等；尽量使用缓存技术；</p><h2 id="5-设置单次访问合适的检索数据量"><a href="#5-设置单次访问合适的检索数据量" class="headerlink" title="[5]设置单次访问合适的检索数据量"></a>[5]设置单次访问合适的检索数据量</h2><p>在SQL<em>Plus , SQL</em>Forms和Pro*C中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为200</p><span id="more"></span><h2 id="6-使用DECODE函数来减少处理时间"><a href="#6-使用DECODE函数来减少处理时间" class="headerlink" title="[6]使用DECODE函数来减少处理时间"></a>[6]使用DECODE函数来减少处理时间</h2><p>使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表,因为decode函数有短路效应，类似java中短路与，有合适的就会返回而不继续扫描后面的内容</p><h2 id="7-整合简单-无关联的数据库访问"><a href="#7-整合简单-无关联的数据库访问" class="headerlink" title="[7]整合简单,无关联的数据库访问"></a>[7]整合简单,无关联的数据库访问</h2><p>如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系),原因见**[4]**</p><h2 id="8-删除重复记录，最高效的方法"><a href="#8-删除重复记录，最高效的方法" class="headerlink" title="[8]删除重复记录，最高效的方法"></a>[8]删除重复记录，最高效的方法</h2><p>因为这里使用的是rowid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE</span><br><span class="line">FROM EMP E</span><br><span class="line">WHERE E.ROWID &gt;</span><br><span class="line">    (SELECT MIN(X.ROWID)</span><br><span class="line">     FROM EMP X</span><br><span class="line">     WHERE X.EMP_NO = E.EMP_NO);</span><br></pre></td></tr></table></figure><h2 id="9-用TRUNCATE替代DELETE"><a href="#9-用TRUNCATE替代DELETE" class="headerlink" title="[9]用TRUNCATE替代DELETE"></a>[9]用TRUNCATE替代DELETE</h2><p>当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) <strong>而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息</strong>.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (注: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)</p><h2 id="10-尽量多使用COMMIT"><a href="#10-尽量多使用COMMIT" class="headerlink" title="[10]尽量多使用COMMIT"></a>[10]尽量多使用COMMIT</h2><p>只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少:<br>COMMIT所释放的资源:</p><ol><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo log buffer 中的空间</li><li>ORACLE为管理上述3种资源中的内部花费</li></ol><h2 id="11-用Where子句替换HAVING子句"><a href="#11-用Where子句替换HAVING子句" class="headerlink" title="[11]用Where子句替换HAVING子句"></a>[11]用Where子句替换HAVING子句</h2><p>避免使用HAVING子句, <strong>HAVING在检索出所有记录后对结果集进行过滤。这个处理需要排序,总计等操作</strong>。 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，<strong>因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的</strong>，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里</p><h2 id="12-减少对表的查询"><a href="#12-减少对表的查询" class="headerlink" title="[12]减少对表的查询"></a>[12]减少对表的查询</h2><p>在含有子查询的SQL语句中,要特别注意减少对表的查询。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT TAB_NAME</span><br><span class="line">FROM TABLES</span><br><span class="line">WHERE (TAB_NAME,</span><br><span class="line">       DB_VER) =</span><br><span class="line">    (SELECT TAB_NAME,</span><br><span class="line">            DB_VER</span><br><span class="line">     FROM TAB_COLUMNS</span><br><span class="line">     WHERE VERSION = 604)</span><br></pre></td></tr></table></figure><h2 id="13-通过内部函数提高SQL效率"><a href="#13-通过内部函数提高SQL效率" class="headerlink" title="[13]通过内部函数提高SQL效率"></a>[13]通过内部函数提高SQL效率</h2><p>复杂的SQL往往牺牲了执行效率。能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的。一般把复杂的sql分解再拼起来。</p><h2 id="14-使用表的别名-Alias"><a href="#14-使用表的别名-Alias" class="headerlink" title="[14]使用表的别名(Alias)"></a>[14]使用表的别名(Alias)</h2><p>当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p><h2 id="15-用EXISTS替代IN、用NOT-EXISTS替代NOT-IN"><a href="#15-用EXISTS替代IN、用NOT-EXISTS替代NOT-IN" class="headerlink" title="[15]用EXISTS替代IN、用NOT EXISTS替代NOT IN"></a>[15]用EXISTS替代IN、用NOT EXISTS替代NOT IN</h2><p>在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接。在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。在子查询中,NOT IN子句将执行一个内部的排序和合并。无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历).。为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.</p><p>高效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM EMP (基础表)</span><br><span class="line">WHERE EMPNO &gt; 0</span><br><span class="line">  AND EXISTS</span><br><span class="line">    (SELECT &#x27;X&#x27;  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC = &#x27;MELB&#x27;)</span><br></pre></td></tr></table></figure><p>低效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM EMP (基础表)</span><br><span class="line">WHERE EMPNO &gt; 0</span><br><span class="line">  AND DEPTNO IN</span><br><span class="line">    (SELECT DEPTNO</span><br><span class="line">     FROM DEPT</span><br><span class="line">     WHERE LOC = &#x27;MELB&#x27;)</span><br></pre></td></tr></table></figure><h2 id="16-识别’低效执行’的SQL语句"><a href="#16-识别’低效执行’的SQL语句" class="headerlink" title="[16]识别’低效执行’的SQL语句"></a>[16]识别’低效执行’的SQL语句</h2><p>虽然目前各种关于SQL优化的图形化工具层出不穷</p><p>但是写出自己的SQL工具来解决问题始终是一个最好的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT EXECUTIONS,</span><br><span class="line">       DISK_READS,</span><br><span class="line">       BUFFER_GETS,</span><br><span class="line">       ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio,</span><br><span class="line">       ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,</span><br><span class="line">       SQL_TEXT</span><br><span class="line">FROM V$SQLAREA</span><br><span class="line">WHERE EXECUTIONS&gt;0</span><br><span class="line">  AND BUFFER_GETS &gt; 0</span><br><span class="line">  AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8</span><br><span class="line">ORDER BY 4 DESC;</span><br></pre></td></tr></table></figure><h2 id="17-用索引提高效率"><a href="#17-用索引提高效率" class="headerlink" title="[17]用索引提高效率"></a>[17]用索引提高效率</h2><p>索引是表的一个概念部分，用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构。通常，通过索引查询数据比全表扫描要快。 当ORACLE找出执行查询和Update语句的最佳路径时， ORACLE优化器将使用索引。同样在联结多个表时使用索引也可以提高效率。另一个使用索引的好处是，它提供了主键(primary key)的唯一性验证。那些LONG或LONG RAW数据类型，你可以索引几乎所有的列。 通常，在大型表中使用索引特别有效。当然，你也会发现，在扫描小表时，使用索引同样能提高效率。<strong>虽然使用索引能得到查询效率的提高，但是我们也必须注意到它的代价. 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时, 索引本身也会被修改</strong>。这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I&#x2F;O 。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。定期的重构索引是有必要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER  INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt;</span><br></pre></td></tr></table></figure><h2 id="18-用EXISTS替换DISTINCT"><a href="#18-用EXISTS替换DISTINCT" class="headerlink" title="[18]用EXISTS替换DISTINCT"></a>[18]用EXISTS替换DISTINCT</h2><p>当提交一个包含一对多表信息(比如部门表和雇员表)的查询时，避免在SELECT子句中使用DISTINCT。一般可以考虑用EXIST替换，EXISTS 使查询更为迅速，因为RDBMS核心模块将在子查询的条件一旦满足后，立刻返回结果。</p><p>低效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT DEPT_NO,</span><br><span class="line">                DEPT_NAME</span><br><span class="line">FROM DEPT D,</span><br><span class="line">     EMP E</span><br><span class="line">WHERE D.DEPT_NO = E.DEPT_NO</span><br></pre></td></tr></table></figure><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT DEPT_NO,</span><br><span class="line">       DEPT_NAME</span><br><span class="line">FROM DEPT D</span><br><span class="line">WHERE EXISTS</span><br><span class="line">    (SELECT &#x27;X&#x27;</span><br><span class="line">     FROM EMP E</span><br><span class="line">     WHERE E.DEPT_NO = D.DEPT_NO);</span><br></pre></td></tr></table></figure><h2 id="19-sql语句用大写"><a href="#19-sql语句用大写" class="headerlink" title="[19]sql语句用大写"></a>[19]sql语句用大写</h2><p>因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行</p><h2 id="20-在java代码中尽量少用连接符“＋”连接字符串"><a href="#20-在java代码中尽量少用连接符“＋”连接字符串" class="headerlink" title="[20]在java代码中尽量少用连接符“＋”连接字符串"></a>[20]在java代码中尽量少用连接符“＋”连接字符串</h2><p>一般来说StringBuilder(非线程安全)是一个不错的选择</p><h2 id="21-通常避免在索引列上使用NOT"><a href="#21-通常避免在索引列上使用NOT" class="headerlink" title="[21]通常避免在索引列上使用NOT"></a>[21]通常避免在索引列上使用NOT</h2><p>我们要避免在索引列上使用NOT，NOT会产生在和在索引列上使用函数相同的影响。当ORACLE”遇到”NOT，他就会停止使用索引转而执行全表扫描。</p><h2 id="22-避免在索引列上使用计算"><a href="#22-避免在索引列上使用计算" class="headerlink" title="[22]避免在索引列上使用计算"></a>[22]避免在索引列上使用计算</h2><p>WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描。</p><p>举例:</p><p>低效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT … FROM  DEPT  WHERE SAL * 12 &gt; 25000; </span><br></pre></td></tr></table></figure><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT … FROM DEPT WHERE SAL &gt; 25000/12;</span><br></pre></td></tr></table></figure><h2 id="23-用-替代"><a href="#23-用-替代" class="headerlink" title="[23]用&gt;&#x3D;替代&gt;"></a>[23]用&gt;&#x3D;替代&gt;</h2><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  EMP  WHERE  DEPTNO &gt;=4 </span><br></pre></td></tr></table></figure><p>低效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM EMP WHERE DEPTNO &gt;3 </span><br></pre></td></tr></table></figure><p>两者的区别在于，前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO&#x3D;3的记录并且向前扫描到第一个DEPT大于3的记录。</p><h2 id="24-用UNION替换OR-适用于索引列"><a href="#24-用UNION替换OR-适用于索引列" class="headerlink" title="[24]用UNION替换OR (适用于索引列)"></a>[24]用UNION替换OR (适用于索引列)</h2><p>通常情况下，用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫描。注意，以上规则只针对多个索引列有效。如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低。在下面的例子中， LOC_ID 和REGION上都建有索引。</p><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOC_ID,</span><br><span class="line">       LOC_DESC,</span><br><span class="line">       REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE LOC_ID = 10</span><br><span class="line">UNION</span><br><span class="line">SELECT LOC_ID,</span><br><span class="line">       LOC_DESC,</span><br><span class="line">       REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE REGION = &#x27;&#x27;MELBOURNE&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>低效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOC_ID,</span><br><span class="line">       LOC_DESC,</span><br><span class="line">       REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE LOC_ID = 10</span><br><span class="line">  OR REGION = &#x27;&#x27;MELBOURNE&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面</p><h2 id="25-用IN来替换OR"><a href="#25-用IN来替换OR" class="headerlink" title="[25]用IN来替换OR"></a>[25]用IN来替换OR</h2><p>这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的。</p><p>低效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 </span><br></pre></td></tr></table></figure><p>高效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT… FROM LOCATION WHERE LOC_IN  IN (10,20,30);</span><br></pre></td></tr></table></figure><h2 id="26-避免在索引列上使用IS-NULL和IS-NOT-NULL"><a href="#26-避免在索引列上使用IS-NULL和IS-NOT-NULL" class="headerlink" title="[26]避免在索引列上使用IS NULL和IS NOT NULL"></a>[26]避免在索引列上使用IS NULL和IS NOT NULL</h2><p>避免在索引中使用任何可以为空的列，<strong>ORACLE将无法使用该索引</strong>。对于单列索引，如果列包含空值，索引中将不存在此记录。对于复合索引，如果每个列都为空，索引中同样不存在此记录。如果至少有一个列不为空，则记录存在于索引中。</p><p>举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入)。然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空。 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中，所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引。</p><p>低效: (索引失效)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE IS NOT NULL; </span><br></pre></td></tr></table></figure><p>高效: (索引有效)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE &gt;=0;</span><br></pre></td></tr></table></figure><h2 id="27-总是使用索引的第一个列"><a href="#27-总是使用索引的第一个列" class="headerlink" title="[27]总是使用索引的第一个列"></a>[27]总是使用索引的第一个列</h2><p>如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,<strong>优化器才会选择使用该索引</strong>。这也是一条简单而重要的规则，当仅引用索引的第二个列时，优化器使用了全表扫描而忽略了索引</p><h2 id="28-用UNION-ALL替换UNION"><a href="#28-用UNION-ALL替换UNION" class="headerlink" title="[28]用UNION-ALL替换UNION"></a>[28]用UNION-ALL替换UNION</h2><p>当SQL语句需要UNION<strong>两个查询结果集合时</strong>,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序。<strong>如果用UNION ALL替代UNION, 这样排序就不是必要了</strong>。效率就会因此得到提高。需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。因此各位还是要从业务需求分析使用UNION ALL的可行性。 UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存。对于这块内存的优化也是相当重要的。下面的SQL可以用来查询排序的消耗量。</p><p>低效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT ACCT_NUM,</span><br><span class="line">       BALANCE_AMT</span><br><span class="line">FROM DEBIT_TRANSACTIONS</span><br><span class="line">WHERE TRAN_DATE = &#x27;31-DEC-95&#x27;</span><br><span class="line">UNION</span><br><span class="line">SELECT ACCT_NUM,</span><br><span class="line">       BALANCE_AMT</span><br><span class="line">FROM DEBIT_TRANSACTIONS</span><br><span class="line">WHERE TRAN_DATE = &#x27;31-DEC-95&#x27;</span><br></pre></td></tr></table></figure><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT ACCT_NUM,</span><br><span class="line">       BALANCE_AMT</span><br><span class="line">FROM DEBIT_TRANSACTIONS</span><br><span class="line">WHERE TRAN_DATE = &#x27;31-DEC-95&#x27;</span><br><span class="line">  UNION ALL</span><br><span class="line">  SELECT ACCT_NUM,</span><br><span class="line">         BALANCE_AMT</span><br><span class="line">  FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = &#x27;31-DEC-95&#x27;</span><br></pre></td></tr></table></figure><h2 id="29-用WHERE替代ORDER-BY"><a href="#29-用WHERE替代ORDER-BY" class="headerlink" title="[29]用WHERE替代ORDER BY"></a>[29]用WHERE替代ORDER BY</h2><p>ORDER BY 子句只在两种严格的条件下使用索引</p><p>ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序</p><p>ORDER BY中所有的列必须定义为非空</p><p>WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列</p><p>例如:</p><p>表DEPT包含以下列:</p><p>DEPT_CODE PK NOT NULL</p><p>DEPT_DESC NOT NULL</p><p>DEPT_TYPE NULL</p><p>低效: (索引不被使用)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DEPT_CODE FROM  DEPT  ORDER BY  DEPT_TYPE </span><br></pre></td></tr></table></figure><p>高效: (使用索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DEPT_CODE  FROM  DEPT  WHERE  DEPT_TYPE &gt; 0</span><br></pre></td></tr></table></figure><h2 id="30-避免改变索引列的类型"><a href="#30-避免改变索引列的类型" class="headerlink" title="[30]避免改变索引列的类型"></a>[30]避免改变索引列的类型</h2><p>当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换</p><p>假设 EMPNO是一个数值类型的索引列.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT …  FROM EMP  WHERE  EMPNO = &#x27;123&#x27; </span><br></pre></td></tr></table></figure><p>实际上,经过ORACLE类型转换, 语句转化为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT …  FROM EMP  WHERE  EMPNO = TO_NUMBER(&#x27;123&#x27;) </span><br></pre></td></tr></table></figure><p>幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变</p><p>现在,假设EMP_TYPE是一个字符类型的索引列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT …  FROM EMP  WHERE EMP_TYPE = 123 </span><br></pre></td></tr></table></figure><p>这个语句被ORACLE转换为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT …  FROM EMP  WHERETO_NUMBER(EMP_TYPE)=123 </span><br></pre></td></tr></table></figure><p>因为内部发生的类型转换, 这个索引将不会被用到!</p><p>为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来。 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型</p><h2 id="31-需要当心的WHERE子句"><a href="#31-需要当心的WHERE子句" class="headerlink" title="[31]需要当心的WHERE子句"></a>[31]需要当心的WHERE子句</h2><p>某些SELECT 语句中的WHERE子句不使用索引<br>这里有一些例子</p><p>在下面的例子里,</p><ol><li>‘!&#x3D;’ 将不使用索引。记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中</li><li>‘||’是字符连接函数. 就象其他函数那样, 停用了索引</li><li>‘+’是数学函数. 就象其他数学函数那样, 停用了索引</li><li>相同的索引列不能互相比较,这将会启用全表扫描</li></ol><h2 id="32-检索数据量超过表中30-索引失效"><a href="#32-检索数据量超过表中30-索引失效" class="headerlink" title="[32]检索数据量超过表中30%,索引失效"></a>[32]检索数据量超过表中30%,索引失效</h2><ol><li>如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高</li><li>在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别。 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!</li></ol><h2 id="33-避免使用耗费资源的操作"><a href="#33-避免使用耗费资源的操作" class="headerlink" title="[33]避免使用耗费资源的操作"></a>[33]避免使用耗费资源的操作</h2><p>带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎<br>执行耗费资源的排序(SORT)功能。</p><p>DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序。<br>通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写。</p><p>如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强。</p><h2 id="34-优化GROUP-BY"><a href="#34-优化GROUP-BY" class="headerlink" title="[34]优化GROUP BY"></a>[34]优化GROUP BY</h2><p>提高GROUP BY 语句的效率，可以通过将不需要的记录在GROUP BY 之前过滤掉。</p><p>下面两个查询返回相同结果但第二个明显就快了许多。</p><p>低效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT JOB,</span><br><span class="line">       AVG(SAL)</span><br><span class="line">FROM EMP</span><br><span class="line">GROUP JOB</span><br><span class="line">HAVING JOB = &#x27;PRESIDENT&#x27;</span><br><span class="line">OR JOB = &#x27;MANAGER&#x27;</span><br></pre></td></tr></table></figure><p>高效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT JOB,</span><br><span class="line">       AVG(SAL)</span><br><span class="line">FROM EMP</span><br><span class="line">WHERE JOB = &#x27;PRESIDENT&#x27; </span><br><span class="line">OR JOB = &#x27;MANAGER&#x27;</span><br><span class="line">GROUP JOB</span><br></pre></td></tr></table></figure><p>本文参考其他文章整理而来</p><p>出处：<a href="http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html" target="_blank">http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html</a></p><p>不过互联网上这篇文章很多，都没有版权注明。我也不知道原创是谁！</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/sql/" rel="tag"># sql</a> <a href="/tags/oracle/" rel="tag"># oracle</a> <a href="/tags/oarcle%E4%BC%98%E5%8C%96/" rel="tag"># oarcle优化</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20170120-%E8%AF%A5Java%E8%AF%AD%E5%8F%A5%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/" rel="prev" title="该Java语句创建了多少个对象？"><i class="fa fa-chevron-left"></i> 该Java语句创建了多少个对象？</a></div><div class="post-nav-item"><a href="/20170120-%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8/" rel="next" title="基本排序算法的时间/空间复杂度表">基本排序算法的时间/空间复杂度表 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%80%89%E6%8B%A9%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E8%A1%A8%E5%90%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">[1]选择最有效率的表名顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-WHERE%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">[2]WHERE子句中的连接顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SELECT%E5%AD%90%E5%8F%A5%E4%B8%AD%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E2%80%99-%E2%80%99"><span class="nav-number">3.</span> <span class="nav-text">[3]SELECT子句中避免使用’*’</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%87%8F%E5%B0%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">[4]减少访问数据库的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AE%BE%E7%BD%AE%E5%8D%95%E6%AC%A1%E8%AE%BF%E9%97%AE%E5%90%88%E9%80%82%E7%9A%84%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">[5]设置单次访问合适的检索数据量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BD%BF%E7%94%A8DECODE%E5%87%BD%E6%95%B0%E6%9D%A5%E5%87%8F%E5%B0%91%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">6.</span> <span class="nav-text">[6]使用DECODE函数来减少处理时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%95%B4%E5%90%88%E7%AE%80%E5%8D%95-%E6%97%A0%E5%85%B3%E8%81%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE"><span class="nav-number">7.</span> <span class="nav-text">[7]整合简单,无关联的数据库访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%9C%80%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">[8]删除重复记录，最高效的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%94%A8TRUNCATE%E6%9B%BF%E4%BB%A3DELETE"><span class="nav-number">9.</span> <span class="nav-text">[9]用TRUNCATE替代DELETE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%B0%BD%E9%87%8F%E5%A4%9A%E4%BD%BF%E7%94%A8COMMIT"><span class="nav-number">10.</span> <span class="nav-text">[10]尽量多使用COMMIT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%94%A8Where%E5%AD%90%E5%8F%A5%E6%9B%BF%E6%8D%A2HAVING%E5%AD%90%E5%8F%A5"><span class="nav-number">11.</span> <span class="nav-text">[11]用Where子句替换HAVING子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%87%8F%E5%B0%91%E5%AF%B9%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">12.</span> <span class="nav-text">[12]减少对表的查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E9%80%9A%E8%BF%87%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98SQL%E6%95%88%E7%8E%87"><span class="nav-number">13.</span> <span class="nav-text">[13]通过内部函数提高SQL效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E4%BD%BF%E7%94%A8%E8%A1%A8%E7%9A%84%E5%88%AB%E5%90%8D-Alias"><span class="nav-number">14.</span> <span class="nav-text">[14]使用表的别名(Alias)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E7%94%A8EXISTS%E6%9B%BF%E4%BB%A3IN%E3%80%81%E7%94%A8NOT-EXISTS%E6%9B%BF%E4%BB%A3NOT-IN"><span class="nav-number">15.</span> <span class="nav-text">[15]用EXISTS替代IN、用NOT EXISTS替代NOT IN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E8%AF%86%E5%88%AB%E2%80%99%E4%BD%8E%E6%95%88%E6%89%A7%E8%A1%8C%E2%80%99%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">16.</span> <span class="nav-text">[16]识别’低效执行’的SQL语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E7%94%A8%E7%B4%A2%E5%BC%95%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">17.</span> <span class="nav-text">[17]用索引提高效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%94%A8EXISTS%E6%9B%BF%E6%8D%A2DISTINCT"><span class="nav-number">18.</span> <span class="nav-text">[18]用EXISTS替换DISTINCT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-sql%E8%AF%AD%E5%8F%A5%E7%94%A8%E5%A4%A7%E5%86%99"><span class="nav-number">19.</span> <span class="nav-text">[19]sql语句用大写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%9C%A8java%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E7%94%A8%E8%BF%9E%E6%8E%A5%E7%AC%A6%E2%80%9C%EF%BC%8B%E2%80%9D%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">20.</span> <span class="nav-text">[20]在java代码中尽量少用连接符“＋”连接字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E9%80%9A%E5%B8%B8%E9%81%BF%E5%85%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%BD%BF%E7%94%A8NOT"><span class="nav-number">21.</span> <span class="nav-text">[21]通常避免在索引列上使用NOT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E9%81%BF%E5%85%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97"><span class="nav-number">22.</span> <span class="nav-text">[22]避免在索引列上使用计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E7%94%A8-%E6%9B%BF%E4%BB%A3"><span class="nav-number">23.</span> <span class="nav-text">[23]用&gt;&#x3D;替代&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E7%94%A8UNION%E6%9B%BF%E6%8D%A2OR-%E9%80%82%E7%94%A8%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%88%97"><span class="nav-number">24.</span> <span class="nav-text">[24]用UNION替换OR (适用于索引列)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E7%94%A8IN%E6%9D%A5%E6%9B%BF%E6%8D%A2OR"><span class="nav-number">25.</span> <span class="nav-text">[25]用IN来替换OR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E9%81%BF%E5%85%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%BD%BF%E7%94%A8IS-NULL%E5%92%8CIS-NOT-NULL"><span class="nav-number">26.</span> <span class="nav-text">[26]避免在索引列上使用IS NULL和IS NOT NULL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E6%80%BB%E6%98%AF%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%88%97"><span class="nav-number">27.</span> <span class="nav-text">[27]总是使用索引的第一个列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E7%94%A8UNION-ALL%E6%9B%BF%E6%8D%A2UNION"><span class="nav-number">28.</span> <span class="nav-text">[28]用UNION-ALL替换UNION</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E7%94%A8WHERE%E6%9B%BF%E4%BB%A3ORDER-BY"><span class="nav-number">29.</span> <span class="nav-text">[29]用WHERE替代ORDER BY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E9%81%BF%E5%85%8D%E6%94%B9%E5%8F%98%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">30.</span> <span class="nav-text">[30]避免改变索引列的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E9%9C%80%E8%A6%81%E5%BD%93%E5%BF%83%E7%9A%84WHERE%E5%AD%90%E5%8F%A5"><span class="nav-number">31.</span> <span class="nav-text">[31]需要当心的WHERE子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%E9%87%8F%E8%B6%85%E8%BF%87%E8%A1%A8%E4%B8%AD30-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">32.</span> <span class="nav-text">[32]检索数据量超过表中30%,索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%80%97%E8%B4%B9%E8%B5%84%E6%BA%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">33.</span> <span class="nav-text">[33]避免使用耗费资源的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E4%BC%98%E5%8C%96GROUP-BY"><span class="nav-number">34.</span> <span class="nav-text">[34]优化GROUP BY</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">hisenyuan</p><div class="site-description" itemprop="description">Java R & D</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">266</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">112</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hisenyuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hisenyuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/hisenyuan" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;hisenyuan" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a> </span><span class="links-of-author-item"><a href="https://twitter.com/hisenyuan" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;hisenyuan" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">hisenyuan</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>